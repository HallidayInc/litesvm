// deno-lint-ignore-file

// This section is generated by deno_bindgen (inlined to avoid a separate bindings file).
const { dlopen } = Deno;

const { symbols } = dlopen("/workspace/litesvm/crates/deno-litesvm/../../target/debug/liblitesvm_deno.so", {
  create_default: {
    parameters: [],
    result: 'u32',
    nonblocking: false
  },
  create_basic: {
    parameters: [],
    result: 'u32',
    nonblocking: false
  },
  dispose: {
    parameters: [
      'u32',
    ],
    result: 'void',
    nonblocking: false
  },
  set_default_programs: {
    parameters: [
      'u32',
    ],
    result: 'pointer',
    nonblocking: false
  },
  set_precompiles: {
    parameters: [
      'u32',
    ],
    result: 'pointer',
    nonblocking: false
  },
  set_builtins: {
    parameters: [
      'u32',
    ],
    result: 'pointer',
    nonblocking: false
  },
  set_sysvars: {
    parameters: [
      'u32',
    ],
    result: 'pointer',
    nonblocking: false
  },
  latest_blockhash: {
    parameters: [
      'u32',
    ],
    result: 'pointer',
    nonblocking: false
  },
  expire_blockhash: {
    parameters: [
      'u32',
    ],
    result: 'pointer',
    nonblocking: false
  },
  airdrop: {
    parameters: [
      'u32',
      'buffer',
      'usize',
      'u64',
    ],
    result: 'pointer',
    nonblocking: false
  },
  get_account: {
    parameters: [
      'u32',
      'buffer',
      'usize',
    ],
    result: 'pointer',
    nonblocking: false
  },
  set_account: {
    parameters: [
      'u32',
      'buffer',
      'usize',
      'pointer',
    ],
    result: 'pointer',
    nonblocking: false
  },
  add_program: {
    parameters: [
      'u32',
      'buffer',
      'usize',
      'buffer',
      'usize',
    ],
    result: 'pointer',
    nonblocking: false
  },
  send_legacy_transaction: {
    parameters: [
      'u32',
      'buffer',
      'usize',
    ],
    result: 'pointer',
    nonblocking: false
  },
  send_versioned_transaction: {
    parameters: [
      'u32',
      'buffer',
      'usize',
    ],
    result: 'pointer',
    nonblocking: false
  },
  simulate_legacy_transaction: {
    parameters: [
      'u32',
      'buffer',
      'usize',
    ],
    result: 'pointer',
    nonblocking: false
  },
  simulate_versioned_transaction: {
    parameters: [
      'u32',
      'buffer',
      'usize',
    ],
    result: 'pointer',
    nonblocking: false
  },
  set_transaction_history: {
    parameters: [
      'u32',
      'u64',
    ],
    result: 'pointer',
    nonblocking: false
  },
  minimum_balance_for_rent_exemption: {
    parameters: [
      'u32',
      'u64',
    ],
    result: 'pointer',
    nonblocking: false
  },
  latest_blockhash_string: {
    parameters: [
      'u32',
    ],
    result: 'pointer',
    nonblocking: false
  },
});

export type LiteSvmHandle = number;

export interface SerializableAccount {
  lamports: number;
  data: Uint8Array;
  owner: Uint8Array;
  executable: boolean;
  rent_epoch: number;
}

export interface OperationResult {
  error?: string | null;
}

export interface BytesResult {
  value?: Uint8Array;
  error?: string | null;
}

export interface AccountResult {
  value?: SerializableAccount | null;
  error?: string | null;
}

export type TransactionResultEnvelope =
  | { status: "ok" | "err"; [key: string]: unknown }
  | { status: string; [key: string]: unknown };

export type SimulationResultEnvelope =
  | { status: "ok" | "err"; [key: string]: unknown }
  | { status: string; [key: string]: unknown };

export interface TransactionResponse {
  value?: TransactionResultEnvelope;
  error?: string | null;
}

export interface SimulationResponse {
  value?: SimulationResultEnvelope;
  error?: string | null;
}

export interface U64Result {
  value?: number;
  error?: string | null;
}

export interface StringResult {
  value?: string;
  error?: string | null;
}

const decoder = new TextDecoder();

function decodeResult<T>(ptr: Deno.PointerObject | null): T {
  if (ptr === null) throw new Error("LiteSVM returned null pointer");
  const view = new Deno.UnsafePointerView(ptr);
  const len = view.getUint32(0);
  const buf = view.getArrayBuffer(4, len);
  const json = decoder.decode(new Uint8Array(buf));
  return JSON.parse(json) as T;
}

export function create_default(): LiteSvmHandle {
  return symbols.create_default();
}

export function create_basic(): LiteSvmHandle {
  return symbols.create_basic();
}

export function dispose(arg0: LiteSvmHandle): void {
  return symbols.dispose(arg0);
}

export function set_default_programs(arg0: LiteSvmHandle): OperationResult {
  return decodeResult(symbols.set_default_programs(arg0));
}

export function set_precompiles(arg0: LiteSvmHandle): OperationResult {
  return decodeResult(symbols.set_precompiles(arg0));
}

export function set_builtins(arg0: LiteSvmHandle): OperationResult {
  return decodeResult(symbols.set_builtins(arg0));
}

export function set_sysvars(arg0: LiteSvmHandle): OperationResult {
  return decodeResult(symbols.set_sysvars(arg0));
}

export function latest_blockhash(arg0: LiteSvmHandle): BytesResult {
  return decodeResult(symbols.latest_blockhash(arg0));
}

export function expire_blockhash(arg0: LiteSvmHandle): OperationResult {
  return decodeResult(symbols.expire_blockhash(arg0));
}

export function airdrop(arg0: LiteSvmHandle, arg1: Uint8Array, arg2: number): OperationResult {
  return decodeResult(symbols.airdrop(arg0, arg1, arg1.byteLength, arg2));
}

export function get_account(arg0: LiteSvmHandle, arg1: Uint8Array): AccountResult {
  return decodeResult(symbols.get_account(arg0, arg1, arg1.byteLength));
}

export function set_account(
  arg0: LiteSvmHandle,
  arg1: Uint8Array,
  arg2: SerializableAccount,
): OperationResult {
  // Serialize account as JSON for FFI
  const encoded = new TextEncoder().encode(JSON.stringify(arg2));
  const view = Deno.UnsafePointer.create(encoded);
  if (!view) {
    throw new Error("Failed to create pointer for account data");
  }
  return decodeResult(symbols.set_account(arg0, arg1, arg1.byteLength, view));
}

export function add_program(
  arg0: LiteSvmHandle,
  arg1: Uint8Array,
  arg2: Uint8Array,
): OperationResult {
  return decodeResult(symbols.add_program(arg0, arg1, arg1.byteLength, arg2, arg2.byteLength));
}

export function send_legacy_transaction(arg0: LiteSvmHandle, arg1: Uint8Array): TransactionResponse {
  return decodeResult(symbols.send_legacy_transaction(arg0, arg1, arg1.byteLength));
}

export function send_versioned_transaction(arg0: LiteSvmHandle, arg1: Uint8Array): TransactionResponse {
  return decodeResult(symbols.send_versioned_transaction(arg0, arg1, arg1.byteLength));
}

export function simulate_legacy_transaction(arg0: LiteSvmHandle, arg1: Uint8Array): SimulationResponse {
  return decodeResult(symbols.simulate_legacy_transaction(arg0, arg1, arg1.byteLength));
}

export function simulate_versioned_transaction(arg0: LiteSvmHandle, arg1: Uint8Array): SimulationResponse {
  return decodeResult(symbols.simulate_versioned_transaction(arg0, arg1, arg1.byteLength));
}

export function set_transaction_history(arg0: LiteSvmHandle, arg1: number): OperationResult {
  return decodeResult(symbols.set_transaction_history(arg0, arg1));
}

export function minimum_balance_for_rent_exemption(arg0: LiteSvmHandle, arg1: number): U64Result {
  return decodeResult(symbols.minimum_balance_for_rent_exemption(arg0, arg1));
}

export function latest_blockhash_string(arg0: LiteSvmHandle): StringResult {
  return decodeResult(symbols.latest_blockhash_string(arg0));
}

// Ergonomic wrapper built on top of the raw bindings above.
type Handle = LiteSvmHandle;

type TransactionResult = TransactionResultEnvelope;
type SimulationResult = SimulationResultEnvelope;

type SerializableAccountType = SerializableAccount;

function unwrapVoid(result: { error?: string | null }): void {
  if (result.error) {
    throw new Error(result.error);
  }
}

function unwrapValue<T>(result: { value?: T; error?: string | null }): T {
  if (result.error) {
    throw new Error(result.error);
  }

  if (result.value === undefined) {
    throw new Error("LiteSVM binding returned no value");
  }

  return result.value;
}

function unwrapOptionalValue<T>(result: {
  value?: T | null;
  error?: string | null;
}): T | null {
  if (result.error) {
    throw new Error(result.error);
  }

  return result.value ?? null;
}

export interface LiteSvmOptions {
  /**
   * Start with an empty LiteSVM without default programs or sysvars.
   * Useful for fine-grained control when bootstrapping.
   */
  basic?: boolean;
}

export class LiteSvm {
  #handle: Handle;

  constructor(opts: LiteSvmOptions = {}) {
    this.#handle = opts.basic ? create_basic() : create_default();
  }

  dispose(): void {
    dispose(this.#handle);
  }

  latestBlockhash(): Uint8Array {
    return unwrapValue(latest_blockhash(this.#handle));
  }

  latestBlockhashString(): string {
    return unwrapValue(latest_blockhash_string(this.#handle));
  }

  expireBlockhash(): void {
    unwrapVoid(expire_blockhash(this.#handle));
  }

  setDefaultPrograms(): void {
    unwrapVoid(set_default_programs(this.#handle));
  }

  setPrecompiles(): void {
    unwrapVoid(set_precompiles(this.#handle));
  }

  setBuiltins(): void {
    unwrapVoid(set_builtins(this.#handle));
  }

  setSysvars(): void {
    unwrapVoid(set_sysvars(this.#handle));
  }

  airdrop(pubkey: Uint8Array, lamports: bigint | number): void {
    const value = typeof lamports === "bigint" ? Number(lamports) : lamports;
    unwrapVoid(airdrop(this.#handle, pubkey, value));
  }

  getAccount(pubkey: Uint8Array): SerializableAccountType | null {
    return unwrapOptionalValue(get_account(this.#handle, pubkey));
  }

  setAccount(pubkey: Uint8Array, account: SerializableAccountType): void {
    unwrapVoid(set_account(this.#handle, pubkey, account));
  }

  addProgram(programId: Uint8Array, programBytes: Uint8Array): void {
    unwrapVoid(add_program(this.#handle, programId, programBytes));
  }

  sendLegacyTransaction(bytes: Uint8Array): TransactionResult {
    return unwrapValue(send_legacy_transaction(this.#handle, bytes));
  }

  sendVersionedTransaction(bytes: Uint8Array): TransactionResult {
    return unwrapValue(send_versioned_transaction(this.#handle, bytes));
  }

  simulateLegacyTransaction(bytes: Uint8Array): SimulationResult {
    return unwrapValue(simulate_legacy_transaction(this.#handle, bytes));
  }

  simulateVersionedTransaction(bytes: Uint8Array): SimulationResult {
    return unwrapValue(simulate_versioned_transaction(this.#handle, bytes));
  }

  setTransactionHistory(capacity: number): void {
    unwrapVoid(set_transaction_history(this.#handle, capacity));
  }

  minimumBalanceForRentExemption(dataLength: number): number {
    return Number(
      unwrapValue(minimum_balance_for_rent_exemption(this.#handle, dataLength)),
    );
  }
}

export const createBasic = create_basic;
export const createDefault = create_default;
